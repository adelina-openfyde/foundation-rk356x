Index: kernel-rockchip/sound/soc/rockchip/rockchip_multicodecs.c
===================================================================
--- kernel-rockchip.orig/sound/soc/rockchip/rockchip_multicodecs.c
+++ kernel-rockchip/sound/soc/rockchip/rockchip_multicodecs.c
@@ -185,7 +185,7 @@ static void mc_keys_poll(struct input_de
 		}
 	}
 
-	if (abs(mc_data->keyup_voltage - value) < closest)
+	if (abs(mc_data->keyup_voltage - value) < closest || (value > 300))
 		keycode = 0;
 
 	if (mc_data->last_key && mc_data->last_key != keycode)
@@ -553,8 +553,18 @@ static int wait_locked_card(struct devic
 	return ret;
 }
 
+static void rk_test_shutdown(struct snd_pcm_substream *substream)
+{
+    struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+    struct multicodecs_data *mc_data = snd_soc_card_get_drvdata(rtd->card);
+
+    gpiod_set_value_cansleep(mc_data->spk_ctl_gpio,0);
+    gpiod_set_value_cansleep(mc_data->hp_ctl_gpio,0);
+}
+
 static struct snd_soc_ops rk_ops = {
 	.hw_params = rk_multicodecs_hw_params,
+  .shutdown = rk_test_shutdown,
 };
 
 static int rk_multicodecs_probe(struct platform_device *pdev)
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-12c.dtsi
===================================================================
--- kernel-rockchip.orig/arch/arm64/boot/dts/rockchip/rk3588s-12c.dtsi
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-12c.dtsi
@@ -43,13 +43,13 @@
 */
 
   dp0_sound: dp0-sound {
-      status = "disabled";
+      status = "okay";
       compatible = "rockchip,hdmi";
       rockchip,card-name = "HDMI/DP-rockchip-0";
       rockchip,mclk-fs = <512>;
       rockchip,cpu = <&spdif_tx2>;
       rockchip,codec = <&dp0 1>;
-      rockchip,jack-det;
+//      rockchip,jack-det;
   };
 
 	spdif_tx1_dc: spdif-tx1-dc {
@@ -181,10 +181,22 @@
 		regulator-name = "sdmmc_power";
 		regulator-boot-on;
 		enable-active-high;
-		gpio = <&gpio4 RK_PB4 GPIO_ACTIVE_HIGH>;
+    regulator-always-on;
+		gpio = <&gpio4 RK_PB4 GPIO_ACTIVE_LOW>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&sdmmc_power_en>;
 	};
+/*
+  sdmmc_power: sdmmc-gpio-power {
+    compatible = "regulator-gpio";
+    regulator-name = "sdmmc-gpio-power";
+    enable-active-high;
+    enable-gpios = <&gpio4 RK_PB4 GPIO_ACTIVE_LOW>;
+    gpios-states = <1>;
+    pinctrl-names = "default";
+    pinctrl-0 = <&sdmmc_power_en>;
+  };
+*/
 
 	vcc_lcd_en: vcc-lcd-en {
 		compatible = "regulator-fixed";
@@ -431,15 +443,16 @@
 	max-frequency = <150000000>;
 	no-sdio;
 	no-mmc;
-  /*broken-cd;*/
+  cd-gpios = <&gpio0 RK_PA4 0>;
+  card-detect-delay = <200>;
 	bus-width = <4>;
 	cap-mmc-highspeed;
 	cap-sd-highspeed;
 	disable-wp;
-	sd-uhs-sdr104;
-	pinctrl-0 = <&sdmmc_clk &sdmmc_cmd &sdmmc_bus4>;
-	vmmc-supply = <&sdmmc_power>;
-	vqmmc-supply = <&vccio_sd_s0>;
+	/*sd-uhs-sdr104;*/
+  pinctrl-0 = <&sdmmc_bus4 &sdmmc_clk &sdmmc_cmd &sdmmc_det>;
+/*	vmmc-supply = <&sdmmc_power>; */
+/*	vqmmc-supply = <&vccio_sd_s0>;*/
 	status = "okay";
 };
 
@@ -538,25 +551,55 @@
 };
 
 &vp0 {
-  /delete-property/ rockchip,plane-mask;
-  /delete-property/ rockchip,primary-plane;
+  cursor-win-id=<ROCKCHIP_VOP2_ESMART0>;
+  rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+  rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER0>;
 };
 
 &vp1 {
   cursor-win-id=<ROCKCHIP_VOP2_ESMART1>;
-  rockchip,plane-mask = <( 1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0 |
-        1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+  rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
   rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER1>;
 };
+/*1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0 |*/
 
 &vp2 {
   cursor-win-id=<ROCKCHIP_VOP2_ESMART2>;
-  rockchip,plane-mask = <( 1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2 |
-        1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+  rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+/*        1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;*/
   rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
 };
 
 &vp3 {
-  /delete-property/ rockchip,plane-mask;
-  /delete-property/ rockchip,primary-plane;
+  cursor-win-id=<ROCKCHIP_VOP2_ESMART3>;
+  rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+  rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER3>;
+};
+
+&sdmmc_bus4 {
+	rockchip,pins =
+        /* sdmmc_d0 */
+        <4 RK_PD0 1 &pcfg_pull_up_drv_level_12>,
+        /* sdmmc_d1 */
+        <4 RK_PD1 1 &pcfg_pull_up_drv_level_12>,
+        /* sdmmc_d2 */
+        <4 RK_PD2 1 &pcfg_pull_up_drv_level_12>,
+        /* sdmmc_d3 */
+        <4 RK_PD3 1 &pcfg_pull_up_drv_level_12>;
+};
+
+&sdmmc_clk {
+   rockchip,pins =
+        /* sdmmc_clk */
+        <4 RK_PD5 1 &pcfg_pull_up_drv_level_12>;
+};
+
+&sdmmc_cmd {
+  rockchip,pins =
+        /* sdmmc_cmd */
+        <4 RK_PD4 1 &pcfg_pull_up_drv_level_12>;
+};
+
+&cluster0_opp_table {
+  /delete-node/ opp-408000000;
 };
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-tablet-12c.dtsi
===================================================================
--- kernel-rockchip.orig/arch/arm64/boot/dts/rockchip/rk3588s-tablet-12c.dtsi
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-tablet-12c.dtsi
@@ -157,7 +157,7 @@
     dmic: dmic {
         status = "okay";
         compatible = "simple-audio-card";
-        simple-audio-card,name = "rockchip,dmic";
+        simple-audio-card,name = "rockchip-dmic";
 
         simple-audio-card,dai-link@0 {
             format = "pdm";
@@ -234,10 +234,6 @@
 };
 
 &dp0_sound {
-  /*
-  pinctrl-0 = <&cc_int0_hpdin_l>;
-  hpd-gpios = <&gpio0 RK_PC4 GPIO_ACTIVE_HIGH>;
-  */
   status = "okay";
 };
 
@@ -496,7 +492,7 @@
 		interrupts = <RK_PC4 IRQ_TYPE_LEVEL_LOW>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&usbc0_int>;
-		vbus-supply = <&vbus_typec>;
+		vbus-supply = <&vbus5v0_typec>;
 		status = "okay";
 
 		ports {
@@ -699,7 +695,8 @@
 &pinctrl {
 	charger {
 		charger_ok: charger_ok {
-			rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>;
+			rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>,
+                      <4 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>;
 		};
 	};
 
@@ -816,13 +813,6 @@
               rockchip,pins = <1 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
       };
   };
-/*
-  vga {
-    cc_int0_hpdin_l: cc-int0-hpdin-l {
-      rockchip,pins = <0 RK_PC4 RK_FUNC_GPIO &pcfg_pull_none>;
-    };
-  };
-  */
 };
 
 &pwm14 {
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-12c-rk806-single.dtsi
===================================================================
--- kernel-rockchip.orig/arch/arm64/boot/dts/rockchip/rk3588s-12c-rk806-single.dtsi
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-12c-rk806-single.dtsi
@@ -290,8 +290,7 @@
 				regulator-max-microvolt = <2000000>;
 				regulator-name = "vdd_2v0_pldo_s3";
 				regulator-state-mem {
-					regulator-on-in-suspend;
-					regulator-suspend-microvolt = <2000000>;
+					regulator-off-in-suspend;
 				};
 			};
 
Index: kernel-rockchip/drivers/usb/typec/tcpm/tcpci_husb311.c
===================================================================
--- kernel-rockchip.orig/drivers/usb/typec/tcpm/tcpci_husb311.c
+++ kernel-rockchip/drivers/usb/typec/tcpm/tcpci_husb311.c
@@ -177,6 +177,11 @@ static int husb311_probe(struct i2c_clie
 			return ret;
 	}
 
+  if (regulator_get_mode(chip->vbus) == REGULATOR_MODE_INVALID) {
+          pr_info("[DEBUG] husb311 -> vbus = NULL\n");
+          chip->vbus = NULL;
+  }
+
 	ret = husb311_sw_reset(chip);
 	if (ret < 0) {
 		dev_err(chip->dev, "fail to soft reset, ret = %d\n", ret);
Index: kernel-rockchip/drivers/power/supply/bq25700_charger.c
===================================================================
--- kernel-rockchip.orig/drivers/power/supply/bq25700_charger.c
+++ kernel-rockchip/drivers/power/supply/bq25700_charger.c
@@ -47,6 +47,7 @@ module_param_named(dbg_level, dbg_enable
 #define MAX_CHARGEVOLTAGE		16800000
 #define MAX_CHARGECURRETNT		8128000
 #define MAX_OTGVOLTAGE			20800000
+#define MIN_OTGVOLTAGE      4280000
 #define MAX_OTGCURRENT			6350000
 
 enum bq25700_fields {
@@ -198,6 +199,14 @@ struct bq25700_device {
 	int				pd_charge_only;
 	unsigned int			bc_event;
 	bool				usb_bc;
+  bool        ready;
+  struct power_supply *battery;
+};
+
+struct bq25700_data {
+  const struct regmap_config *regmap_config;
+  const struct reg_field *reg_fields;
+  const int reg_fields_num;
 };
 
 static const struct reg_field bq25700_reg_fields[] = {
@@ -501,12 +510,18 @@ struct bq25700_range {
 	u32 step;
 };
 
+static const struct bq25700_range sc8886_otg_range = {
+       .min = 1280000,
+       .max = 20800000,
+       .step = 128000,
+};
+
 struct bq25700_lookup {
 	const u32 *tbl;
 	u32 size;
 };
 
-static const union {
+static union {
 	struct bq25700_range  rt;
 	struct bq25700_lookup lt;
 } bq25700_tables[] = {
@@ -597,6 +612,14 @@ static void bq25700_disable_charge(struc
 
 static struct bq25700_device *bq25700_charger;
 
+static void bq25700_notify_battery(struct bq25700_device *charger) {
+  struct power_supply *battery = charger->battery;
+  if (IS_ERR_OR_NULL(battery) ||
+      IS_ERR_OR_NULL(battery->desc->external_power_changed))
+    return;
+ // battery->desc->external_power_changed(battery);
+}
+
 static int bq25700_field_read(struct bq25700_device *charger,
 			      enum bq25700_fields field_id)
 {
@@ -935,12 +958,25 @@ static int bq25700_fw_read_u32_props(str
 			dev_err(charger->dev, "ti,input-current is error\n");
 			return -ENODEV;
 		}
-		if ((props[i].tbl_id == TBL_OTGVOL) &&
-		    (property > MAX_OTGVOLTAGE)) {
-			dev_err(charger->dev, "ti,ti,otg-voltage is error\n");
-			return -ENODEV;
-		}
-		if ((props[i].tbl_id == TBL_OTGVOL) &&
+    if (props[i].tbl_id == TBL_OTGVOL) {
+            if (of_device_is_compatible(charger->dev->of_node,
+                                        "southchip,sc8886")) {
+                    pr_info("[xxxx] %s %d\n", __func__, __LINE__);
+                    bq25700_tables[TBL_OTGVOL].rt = sc8886_otg_range;
+
+                    if (property < MIN_OTGVOLTAGE) {
+                            dev_err(charger->dev,
+                                    "ti,otg-voltage is error");
+                            return -ENODEV;
+                    }
+            }
+
+            if (property > MAX_OTGVOLTAGE) {
+                    dev_err(charger->dev, "ti,otg-voltage is error\n");
+                    return -ENODEV;
+            };
+    };
+		if ((props[i].tbl_id == TBL_OTGCUR) &&
 		    (property > MAX_OTGCURRENT)) {
 			dev_err(charger->dev, "ti,otg-current is error\n");
 			return -ENODEV;
@@ -968,7 +1004,7 @@ static int bq25700_hw_init(struct bq2570
 		{CHARGE_CURRENT,	 charger->init_data.ichg},
 		{MAX_CHARGE_VOLTAGE,	 charger->init_data.max_chg_vol},
 		{MIN_SYS_VOTAGE,	 charger->init_data.sys_min_voltage},
-		{OTG_VOLTAGE,	 charger->init_data.otg_voltage},
+/*		{OTG_VOLTAGE,	 charger->init_data.otg_voltage}, */
 		{OTG_CURRENT,	 charger->init_data.otg_current},
 	};
 
@@ -1220,8 +1256,8 @@ static int bq25700_power_supply_init(str
 {
 	struct power_supply_config psy_cfg = { .drv_data = charger, };
 
-	psy_cfg.supplied_to = bq25700_charger_supplied_to;
-	psy_cfg.num_supplicants = ARRAY_SIZE(bq25700_charger_supplied_to);
+ 	psy_cfg.supplied_to = bq25700_charger_supplied_to;
+  psy_cfg.num_supplicants = ARRAY_SIZE(bq25700_charger_supplied_to);
 	psy_cfg.of_node = charger->dev->of_node;
 
 	charger->supply_charger =
@@ -1265,6 +1301,7 @@ static int bq2570x_pd_notifier_call(stru
 	if (prop.intval == 0) {
 		queue_delayed_work(bq->usb_charger_wq, &bq->discnt_work,
 				   msecs_to_jiffies(10));
+    bq25700_notify_battery(bq);
 		return NOTIFY_OK;
 	}
 
@@ -1293,6 +1330,8 @@ static int bq2570x_pd_notifier_call(stru
 		bq25700_get_chip_state(bq, &state);
 		bq->state = state;
 		power_supply_changed(bq->supply_charger);
+    if (bq25700_field_read(bq, AC_STAT))
+      bq25700_notify_battery(bq);
 	}
 	return NOTIFY_OK;
 }
@@ -1316,6 +1355,7 @@ static irqreturn_t bq25700_irq_handler_t
 		charger->typec0_status = USB_STATUS_NONE;
 		charger->typec1_status = USB_STATUS_NONE;
 	}
+  bq25700_notify_battery(charger);
 	irq_set_irq_type(irq, irq_flag | IRQF_ONESHOT);
 
 	return IRQ_HANDLED;
@@ -1487,11 +1527,15 @@ static int bq25700_charger_evt_notifier1
 
 static void bq25700_set_otg_vbus(struct bq25700_device *charger, bool enable)
 {
+  u32 value;
 	DBG("OTG %s\n", enable ? "enable" : "disable");
-
+  value = enable ? charger->init_data.otg_voltage :
+                   bq25700_find_idx(MIN_OTGVOLTAGE, TBL_OTGVOL);
 	if (!IS_ERR_OR_NULL(charger->otg_mode_en_io))
 		gpiod_direction_output(charger->otg_mode_en_io, enable);
-	bq25700_field_write(charger, EN_OTG, enable);
+  bq25700_field_write(charger,OTG_VOLTAGE,value);
+  bq25700_field_write(charger, EN_OTG, enable);
+  bq25700_notify_battery(charger);
 }
 
 static void bq25700_host_evt_worker(struct work_struct *work)
@@ -1752,7 +1796,8 @@ static int bq25700_otg_vbus_enable(struc
 {
 	struct bq25700_device *charger = rdev_get_drvdata(dev);
 
-	bq25700_set_otg_vbus(charger, true);
+  if (charger->ready)
+	  bq25700_set_otg_vbus(charger, true);
 
 	return 0;
 }
@@ -1761,7 +1806,8 @@ static int bq25700_otg_vbus_disable(stru
 {
 	struct bq25700_device *charger = rdev_get_drvdata(dev);
 
-	bq25700_set_otg_vbus(charger, false);
+  if (charger->ready)
+	  bq25700_set_otg_vbus(charger, false);
 
 	return 0;
 }
@@ -1779,10 +1825,17 @@ static int bq25700_otg_vbus_is_enabled(s
 	return val && gpio_status ? 1 : 0;
 }
 
+static unsigned int bq25700_otg_vbus_status(struct regulator_dev *dev)
+{
+  struct bq25700_device *charger = rdev_get_drvdata(dev);
+	return charger->ready ? REGULATOR_MODE_NORMAL : REGULATOR_MODE_INVALID;
+}
+
 static const struct regulator_ops bq25700_otg_vbus_ops = {
 	.enable = bq25700_otg_vbus_enable,
 	.disable = bq25700_otg_vbus_disable,
 	.is_enabled = bq25700_otg_vbus_is_enabled,
+  .get_mode = bq25700_otg_vbus_status,
 };
 
 static const struct regulator_desc bq25700_otg_vbus_desc = {
@@ -1928,20 +1981,21 @@ static int bq25700_parse_dt(struct bq257
 	return 0;
 }
 
-static int bq25700_probe(struct i2c_client *client,
-			 const struct i2c_device_id *id)
+static int probe_cnt = 0;
+
+static int bq25700_register(struct i2c_client *client,
+			 const struct bq25700_data *bq25700_data)
 {
 	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
 	struct device *dev = &client->dev;
 	struct bq25700_device *charger;
-	struct device_node *charger_np;
 	int ret = 0;
 	u32 i = 0;
 	int irq_flag;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))
 		return -EIO;
-
+	probe_cnt++;
 	charger = devm_kzalloc(&client->dev, sizeof(*charger), GFP_KERNEL);
 	if (!charger)
 		return -EINVAL;
@@ -1949,51 +2003,26 @@ static int bq25700_probe(struct i2c_clie
 	charger->client = client;
 	charger->dev = dev;
 
-	charger_np = of_find_compatible_node(NULL, NULL, "ti,bq25700");
-	if (!charger_np)
-		charger_np = of_find_compatible_node(NULL, NULL, "southchip,sc8885");
-	if (charger_np) {
-		charger->regmap = devm_regmap_init_i2c(client,
-						       &bq25700_regmap_config);
-		if (IS_ERR(charger->regmap)) {
-			dev_err(&client->dev, "Failed to initialize regmap\n");
-			return -EINVAL;
-		}
-
-		for (i = 0; i < ARRAY_SIZE(bq25700_reg_fields); i++) {
-			const struct reg_field *reg_fields = bq25700_reg_fields;
-
-			charger->rmap_fields[i] =
-				devm_regmap_field_alloc(dev,
-							charger->regmap,
-							reg_fields[i]);
-			if (IS_ERR(charger->rmap_fields[i])) {
-				dev_err(dev, "cannot allocate regmap field\n");
-				return PTR_ERR(charger->rmap_fields[i]);
-			}
-		}
-	} else {
-		charger->regmap = devm_regmap_init_i2c(client,
-						       &bq25703_regmap_config);
-
-		if (IS_ERR(charger->regmap)) {
-			dev_err(&client->dev, "Failed to initialize regmap\n");
-			return -EINVAL;
-		}
+	charger->regmap = devm_regmap_init_i2c(client,
+					       bq25700_data->regmap_config);
+	if (IS_ERR(charger->regmap)) {
+		dev_err(&client->dev, "Failed to initialize regmap\n");
+		return -EINVAL;
+	}
 
-		for (i = 0; i < ARRAY_SIZE(bq25703_reg_fields); i++) {
-			const struct reg_field *reg_fields = bq25703_reg_fields;
+	for (i = 0; i < bq25700_data->reg_fields_num ; i++) {
+		const struct reg_field *reg_fields = bq25700_data->reg_fields;
 
-			charger->rmap_fields[i] =
-				devm_regmap_field_alloc(dev,
-							charger->regmap,
-							reg_fields[i]);
-			if (IS_ERR(charger->rmap_fields[i])) {
-				dev_err(dev, "cannot allocate regmap field\n");
-				return PTR_ERR(charger->rmap_fields[i]);
-			}
+		charger->rmap_fields[i] =
+			devm_regmap_field_alloc(dev,
+						charger->regmap,
+						reg_fields[i]);
+		if (IS_ERR(charger->rmap_fields[i])) {
+			dev_err(dev, "cannot allocate regmap field\n");
+			return PTR_ERR(charger->rmap_fields[i]);
 		}
 	}
+
 	i2c_set_clientdata(client, charger);
 
 	/*read chip id. Confirm whether to support the chip*/
@@ -2013,20 +2042,26 @@ static int bq25700_probe(struct i2c_clie
 	} else {
 		return -ENODEV;
 	}
+  charger->ready = false;
 
 	/*
 	 * Make sure battery online, otherwise, writing INPUT_CURRENT and
 	 * CHARGE_CURRENT would make system power off
 	 */
-	if (of_parse_phandle(charger->dev->of_node, "ti,battery", 0)) {
-		if (IS_ERR_OR_NULL(power_supply_get_by_phandle(
-						charger->dev->of_node,
-						"ti,battery"))) {
-			dev_info(charger->dev, "No battery found\n");
-			return -EPROBE_DEFER;
+  charger->battery = power_supply_get_by_phandle(
+                  dev->of_node,
+                  "ti,battery");
+	if (IS_ERR_OR_NULL(charger->battery)) {
+		dev_warn(charger->dev, "No battery found\n");
+		if (probe_cnt > 3) {
+			dev_info(charger->dev, "typec vbus registered anyway\n");
+			return bq25700_register_otg_vbus_regulator(charger);
 		}
-		dev_info(charger->dev, "Battery found\n");
+		return -EPROBE_DEFER;
 	}
+	dev_info(charger->dev, "Battery found\n");
+
+	charger->ready = true;
 
 	ret = bq25700_hw_init(charger);
 	if (ret < 0) {
@@ -2109,12 +2144,24 @@ static const struct i2c_device_id bq2570
 };
 MODULE_DEVICE_TABLE(i2c, bq25700_i2c_ids);
 
+static const struct bq25700_data bq25700_driver_data = {
+  .regmap_config = &bq25700_regmap_config,
+  .reg_fields = bq25700_reg_fields,
+  .reg_fields_num = ARRAY_SIZE(bq25700_reg_fields),
+};
+
+static const struct bq25700_data bq25703_driver_data = {
+  .regmap_config = &bq25703_regmap_config,
+  .reg_fields = bq25703_reg_fields,
+  .reg_fields_num = ARRAY_SIZE(bq25703_reg_fields),
+};
+
 #ifdef CONFIG_OF
 static const struct of_device_id bq25700_of_match[] = {
-	{ .compatible = "ti,bq25700", },
-	{ .compatible = "ti,bq25703", },
-	{ .compatible = "southchip,sc8885", },
-	{ .compatible = "southchip,sc8886", },
+	{ .compatible = "ti,bq25700", .data = &bq25700_driver_data },
+	{ .compatible = "ti,bq25703", .data = &bq25703_driver_data },
+	{ .compatible = "southchip,sc8885", .data = &bq25700_driver_data },
+	{ .compatible = "southchip,sc8886", .data = &bq25703_driver_data },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, bq25700_of_match);
@@ -2124,6 +2171,15 @@ static const struct of_device_id bq25700
 };
 #endif
 
+static int bq25700_probe(struct i2c_client *client,
+       const struct i2c_device_id *id) {
+  const struct bq25700_data *bq25700_data;
+  const struct of_device_id *match;
+  match = of_match_node(bq25700_of_match, client->dev.of_node);
+  bq25700_data = match->data;
+  return bq25700_register(client, bq25700_data);
+}
+
 static struct i2c_driver bq25700_driver = {
 	.probe		= bq25700_probe,
 	.shutdown	= bq25700_shutdown,
Index: kernel-rockchip/drivers/cpufreq/Kconfig
===================================================================
--- kernel-rockchip.orig/drivers/cpufreq/Kconfig
+++ kernel-rockchip/drivers/cpufreq/Kconfig
@@ -5,8 +5,8 @@ config CPU_FREQ
 	bool "CPU Frequency scaling"
 	select SRCU
 	help
-	  CPU Frequency scaling allows you to change the clock speed of 
-	  CPUs on the fly. This is a nice method to save power, because 
+	  CPU Frequency scaling allows you to change the clock speed of
+	  CPUs on the fly. This is a nice method to save power, because
 	  the lower the CPU clock speed, the less power the CPU consumes.
 
 	  Note that this driver doesn't automatically change the CPU
@@ -72,7 +72,7 @@ config CPU_FREQ_DEFAULT_GOV_USERSPACE
 	select CPU_FREQ_GOV_USERSPACE
 	help
 	  Use the CPUFreq governor 'userspace' as default. This allows
-	  you to set the CPU frequency manually or when a userspace 
+	  you to set the CPU frequency manually or when a userspace
 	  program shall be able to set the CPU dynamically without having
 	  to enable the userspace governor manually.
 
@@ -141,7 +141,7 @@ config CPU_FREQ_GOV_USERSPACE
 	help
 	  Enable this cpufreq governor when you either want to set the
 	  CPU frequency manually or when a userspace program shall
-	  be able to set the CPU dynamically, like on LART 
+	  be able to set the CPU dynamically, like on LART
 	  <http://www.lartmaker.nl/>.
 
 	  To compile this driver as a module, choose M here: the
@@ -156,11 +156,11 @@ config CPU_FREQ_GOV_ONDEMAND
 	select CPU_FREQ_GOV_COMMON
 	help
 	  'ondemand' - This driver adds a dynamic cpufreq policy governor.
-	  The governor does a periodic polling and 
+	  The governor does a periodic polling and
 	  changes frequency based on the CPU utilization.
 	  The support for this governor depends on CPU capability to
 	  do fast frequency switching (i.e, very low latency frequency
-	  transitions). 
+	  transitions).
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called cpufreq_ondemand.
@@ -210,6 +210,17 @@ config CPU_FREQ_GOV_SCHEDUTIL
 
 	  If in doubt, say N.
 
+config CPU_BOOST
+  tristate "Input event based short term CPU freq booster"
+  depends on INPUT
+  help
+    This driver monitors events from input devices, such as
+    touchscreen, trackpad, keyboard, etc., and boosts frequency
+    of all CPUs in the system in response to user interacting with
+    the device.
+
+    If in doubt, say N.
+
 comment "CPU frequency scaling drivers"
 
 config CPUFREQ_DT
Index: kernel-rockchip/drivers/cpufreq/Makefile
===================================================================
--- kernel-rockchip.orig/drivers/cpufreq/Makefile
+++ kernel-rockchip/drivers/cpufreq/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= c
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
 obj-$(CONFIG_CPU_FREQ_GOV_COMMON)		+= cpufreq_governor.o
 obj-$(CONFIG_CPU_FREQ_GOV_ATTR_SET)	+= cpufreq_governor_attr_set.o
+obj-$(CONFIG_CPU_BOOST)     += cpu-boost.o
 
 obj-$(CONFIG_CPUFREQ_DT)		+= cpufreq-dt.o
 obj-$(CONFIG_CPUFREQ_DT_PLATDEV)	+= cpufreq-dt-platdev.o
Index: kernel-rockchip/drivers/cpufreq/cpu-boost.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/cpufreq/cpu-boost.c
@@ -0,0 +1,306 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Loosely based on cpu-boost.c from Android tree
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/notifier.h>
+#include <linux/pm_qos.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+static unsigned int cpuboost_input_boost_freq_percent;
+module_param_named(input_boost_freq_percent,
+		   cpuboost_input_boost_freq_percent, uint, 0644);
+MODULE_PARM_DESC(input_boost_freq_percent,
+		 "Percentage of max frequency of CPU to be used as boost frequency");
+
+static unsigned int cpuboost_input_boost_ms = 40;
+module_param_named(input_boost_ms,
+		   cpuboost_input_boost_ms, uint, 0644);
+MODULE_PARM_DESC(input_boost_ms, "Duration of input boost (msec)");
+
+static unsigned int cpuboost_input_boost_interval_ms = 150;
+module_param_named(input_boost_interval_ms,
+		   cpuboost_input_boost_interval_ms, uint, 0644);
+MODULE_PARM_DESC(input_boost_interval_ms,
+		 "Interval between input events to reactivate input boost (msec)");
+
+DEFINE_MUTEX(cpuboost_mutex);
+
+static bool cpuboost_boost_active;
+
+static LIST_HEAD(cpuboost_policy_list);
+
+struct cpuboost_policy_node {
+	struct list_head policy_list;
+	struct freq_qos_request qos_req;
+	struct cpufreq_policy *policy;
+};
+
+static int cpuboost_policy_notifier(struct notifier_block *nb,
+				    unsigned long val, void *data)
+{
+	struct cpufreq_policy *policy = data;
+	struct cpuboost_policy_node *node;
+	int ret;
+	bool found;
+
+	switch (val) {
+	case CPUFREQ_CREATE_POLICY:
+		node = kzalloc(sizeof(*node), GFP_KERNEL);
+		if (!node)
+			break;
+
+		node->policy = policy;
+
+		/*
+		 * Always init to no boost and we'll get the boost the next
+		 * time input comes in.
+		 */
+		ret = freq_qos_add_request(&policy->constraints,
+					   &node->qos_req, FREQ_QOS_MIN, 0);
+		if (ret < 0) {
+			pr_warn("Failed to add input boost: %d\n", ret);
+			kfree(node);
+			break;
+		}
+
+		mutex_lock(&cpuboost_mutex);
+		list_add(&node->policy_list, &cpuboost_policy_list);
+		mutex_unlock(&cpuboost_mutex);
+
+		return NOTIFY_OK;
+
+	case CPUFREQ_REMOVE_POLICY:
+		mutex_lock(&cpuboost_mutex);
+		found = false;
+		list_for_each_entry(node, &cpuboost_policy_list, policy_list) {
+			if (node->policy == policy) {
+				found = true;
+				break;
+			}
+		}
+
+		if (!found) {
+			pr_warn("Couldn't find input boost for policy\n");
+			mutex_unlock(&cpuboost_mutex);
+			break;
+		}
+		list_del(&node->policy_list);
+		mutex_unlock(&cpuboost_mutex);
+
+		ret = freq_qos_remove_request(&node->qos_req);
+		kfree(node);
+		if (ret < 0) {
+			pr_warn("Failed to remove input boost: %d\n", ret);
+			break;
+		}
+
+		return NOTIFY_OK;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block cpuboost_policy_nb = {
+	.notifier_call = cpuboost_policy_notifier,
+};
+
+static void cpuboost_toggle_boost(bool boost_active)
+{
+	struct cpuboost_policy_node *node;
+	int ret;
+	s32 freq = 0;
+
+	mutex_lock(&cpuboost_mutex);
+	cpuboost_boost_active = boost_active;
+	list_for_each_entry(node, &cpuboost_policy_list, policy_list) {
+		if (boost_active)
+			freq = node->policy->cpuinfo.max_freq / 100 *
+			       cpuboost_input_boost_freq_percent;
+		ret = freq_qos_update_request(&node->qos_req, freq);
+		if (ret < 0)
+			pr_warn("Error updating cpuboost request: %d\n", ret);
+	}
+	mutex_unlock(&cpuboost_mutex);
+}
+
+static void cpuboost_cancel_input_boost(struct work_struct *work)
+{
+	cpuboost_toggle_boost(false);
+}
+static DECLARE_DELAYED_WORK(cpuboost_cancel_boost_work,
+			    cpuboost_cancel_input_boost);
+
+static void cpuboost_do_input_boost(struct work_struct *work)
+{
+	mod_delayed_work(system_wq, &cpuboost_cancel_boost_work,
+			 msecs_to_jiffies(cpuboost_input_boost_ms));
+
+	cpuboost_toggle_boost(true);
+}
+static DECLARE_WORK(cpuboost_input_boost_work, cpuboost_do_input_boost);
+
+static void cpuboost_input_event(struct input_handle *handle,
+				 unsigned int type, unsigned int code,
+				 int value)
+{
+	static unsigned long last_event_time;
+	unsigned long now = jiffies;
+	unsigned int threshold;
+
+	if (!cpuboost_input_boost_freq_percent)
+		return;
+
+	threshold = msecs_to_jiffies(cpuboost_input_boost_interval_ms);
+	if (time_after(now, last_event_time + threshold))
+		queue_work(system_highpri_wq, &cpuboost_input_boost_work);
+
+	last_event_time = now;
+}
+
+static int cpuboost_input_connect(struct input_handler *handler,
+				  struct input_dev *dev,
+				  const struct input_device_id *id)
+{
+	struct input_handle *handle;
+	int error;
+
+	handle = kzalloc(sizeof(struct input_handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = "cpu-boost";
+
+	error = input_register_handle(handle);
+	if (error)
+		goto err2;
+
+	error = input_open_device(handle);
+	if (error)
+		goto err1;
+
+	return 0;
+
+err1:
+	input_unregister_handle(handle);
+err2:
+	kfree(handle);
+	return error;
+}
+
+static void cpuboost_input_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+static const struct input_device_id cpuboost_ids[] = {
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
+			 INPUT_DEVICE_ID_MATCH_ABSBIT,
+		.evbit = { BIT_MASK(EV_ABS) },
+		.absbit = { [BIT_WORD(ABS_MT_POSITION_X)] =
+			    BIT_MASK(ABS_MT_POSITION_X) |
+			    BIT_MASK(ABS_MT_POSITION_Y) },
+	}, /* multi-touch touchscreen */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_ABS) },
+		.absbit = { [BIT_WORD(ABS_X)] = BIT_MASK(ABS_X) }
+
+	}, /* stylus or joystick device */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+		.keybit = { [BIT_WORD(BTN_LEFT)] = BIT_MASK(BTN_LEFT) },
+	}, /* pointer (e.g. trackpad, mouse) */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+		.keybit = { [BIT_WORD(KEY_ESC)] = BIT_MASK(KEY_ESC) },
+	}, /* keyboard */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
+				INPUT_DEVICE_ID_MATCH_KEYBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+		.keybit = {[BIT_WORD(BTN_JOYSTICK)] = BIT_MASK(BTN_JOYSTICK) },
+	}, /* joysticks not caught by ABS_X above */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
+				INPUT_DEVICE_ID_MATCH_KEYBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+		.keybit = { [BIT_WORD(BTN_GAMEPAD)] = BIT_MASK(BTN_GAMEPAD) },
+	}, /* gamepad */
+	{ },
+};
+
+static struct input_handler cpuboost_input_handler = {
+	.event          = cpuboost_input_event,
+	.connect        = cpuboost_input_connect,
+	.disconnect     = cpuboost_input_disconnect,
+	.name           = "cpu-boost",
+	.id_table       = cpuboost_ids,
+};
+
+static int __init cpuboost_init(void)
+{
+	int error;
+
+	error = cpufreq_register_notifier(&cpuboost_policy_nb,
+					  CPUFREQ_POLICY_NOTIFIER);
+	if (error) {
+		pr_err("failed to register input handler: %d\n", error);
+		return error;
+	}
+
+	error = input_register_handler(&cpuboost_input_handler);
+	if (error) {
+		pr_err("failed to register input handler: %d\n", error);
+		cpufreq_unregister_notifier(&cpuboost_policy_nb,
+					    CPUFREQ_POLICY_NOTIFIER);
+		return error;
+	}
+
+	return 0;
+}
+module_init(cpuboost_init);
+
+static void __exit cpuboost_exit(void)
+{
+	input_unregister_handler(&cpuboost_input_handler);
+
+	flush_work(&cpuboost_input_boost_work);
+	cancel_delayed_work_sync(&cpuboost_cancel_boost_work);
+
+	cpufreq_unregister_notifier(&cpuboost_policy_nb,
+				    CPUFREQ_POLICY_NOTIFIER);
+}
+module_exit(cpuboost_exit);
+
+MODULE_DESCRIPTION("Input event based short term CPU frequency booster");
+MODULE_LICENSE("GPL v2");
Index: kernel-rockchip/sound/soc/soc-generic-dmaengine-pcm.c
===================================================================
--- kernel-rockchip.orig/sound/soc/soc-generic-dmaengine-pcm.c
+++ kernel-rockchip/sound/soc/soc-generic-dmaengine-pcm.c
@@ -15,7 +15,7 @@
 
 #include <sound/dmaengine_pcm.h>
 
-static unsigned int prealloc_buffer_size_kbytes = 512;
+static unsigned int prealloc_buffer_size_kbytes = 1024;
 module_param(prealloc_buffer_size_kbytes, uint, 0444);
 MODULE_PARM_DESC(prealloc_buffer_size_kbytes, "Preallocate DMA buffer size (KB).");
 
Index: kernel-rockchip/drivers/power/supply/sbs-battery.c
===================================================================
--- kernel-rockchip.orig/drivers/power/supply/sbs-battery.c
+++ kernel-rockchip/drivers/power/supply/sbs-battery.c
@@ -51,6 +51,8 @@ enum {
 	REG_CHARGE_VOLTAGE,
 };
 
+#define SBS_POLL_TIME_OUT 5000
+
 #define REG_ADDR_SPEC_INFO		0x1A
 #define SPEC_INFO_VERSION_MASK		GENMASK(7, 4)
 #define SPEC_INFO_VERSION_SHIFT		4
@@ -201,6 +203,7 @@ struct sbs_info {
 	struct delayed_work		work;
 	struct mutex			mode_lock;
 	u32				flags;
+  struct timer_list timer;
 };
 
 static char model_name[I2C_SMBUS_BLOCK_MAX + 1];
@@ -617,13 +620,6 @@ static int sbs_get_battery_property(stru
 
 		sbs_status_correct(client, &val->intval);
 
-		if (chip->poll_time == 0)
-			chip->last_state = val->intval;
-		else if (chip->last_state != val->intval) {
-			cancel_delayed_work_sync(&chip->work);
-			power_supply_changed(chip->power_supply);
-			chip->poll_time = 0;
-		}
 	} else {
 		if (psp == POWER_SUPPLY_PROP_STATUS)
 			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
@@ -635,6 +631,13 @@ static int sbs_get_battery_property(stru
 		else
 			val->intval = 0;
 	}
+	if (chip->poll_time == 0)
+		chip->last_state = val->intval;
+	else if (chip->last_state != val->intval) {
+		cancel_delayed_work_sync(&chip->work);
+		power_supply_changed(chip->power_supply);
+		chip->poll_time = 0;
+	}
 
 	return 0;
 }
@@ -998,10 +1001,14 @@ static void sbs_supply_changed(struct sb
 	struct power_supply *battery = chip->power_supply;
 	int ret;
 
-	ret = gpiod_get_value_cansleep(chip->gpio_detect);
-	if (ret < 0)
-		return;
-	sbs_update_presence(chip, ret);
+  if (chip->gpio_detect) {
+  	ret = gpiod_get_value_cansleep(chip->gpio_detect);
+  	if (ret < 0)
+  		return;
+	  sbs_update_presence(chip, ret);
+  }else {
+    sbs_update_presence(chip, 1);
+  }
 	power_supply_changed(battery);
 }
 
@@ -1071,6 +1078,21 @@ static const struct power_supply_desc sb
 	.external_power_changed = sbs_external_power_changed,
 };
 
+void sbs_timed_poll(struct timer_list * t) {
+  struct sbs_info *chip = from_timer(chip, t, timer);
+  sbs_external_power_changed(chip->power_supply);
+  mod_timer(t, jiffies + msecs_to_jiffies(SBS_POLL_TIME_OUT));
+}
+
+static inline void sbs_timed_poll_start(struct sbs_info *chip) {
+  timer_setup(&chip->timer, sbs_timed_poll, 0);
+  mod_timer(&chip->timer, jiffies + msecs_to_jiffies(SBS_POLL_TIME_OUT));
+}
+
+static inline void sbs_timed_poll_stop(struct sbs_info *chip) {
+  del_timer_sync(&chip->timer);
+}
+
 static int sbs_probe(struct i2c_client *client)
 {
 	struct sbs_info *chip;
@@ -1177,7 +1199,8 @@ skip_gpio:
 		rc = PTR_ERR(chip->power_supply);
 		goto exit_psupply;
 	}
-
+  if (!chip->gpio_detect)
+    sbs_timed_poll_start(chip);
 	dev_info(&client->dev,
 		"%s: battery gas gauge device registered\n", client->name);
 
@@ -1190,7 +1213,8 @@ exit_psupply:
 static int sbs_remove(struct i2c_client *client)
 {
 	struct sbs_info *chip = i2c_get_clientdata(client);
-
+  if (!chip->gpio_detect)
+    sbs_timed_poll_stop(chip);
 	cancel_delayed_work_sync(&chip->work);
 
 	return 0;
