Index: kernel-rockchip/include/linux/mm.h
===================================================================
--- kernel-rockchip.orig/include/linux/mm.h
+++ kernel-rockchip/include/linux/mm.h
@@ -3408,5 +3408,20 @@ static inline int seal_check_future_writ
 	return 0;
 }
 
+
+static inline void vm_flags_set(struct vm_area_struct *vma,
+                               vm_flags_t flags)
+{
+
+       vma->vm_flags |= flags;
+}
+
+static inline void vm_flags_clear(struct vm_area_struct *vma,
+                                 vm_flags_t flags)
+{
+
+       vma->vm_flags &= ~flags;
+}
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_MM_H */
Index: kernel-rockchip/drivers/rknpu/include/rknpu_drv.h
===================================================================
--- kernel-rockchip.orig/drivers/rknpu/include/rknpu_drv.h
+++ kernel-rockchip/drivers/rknpu/include/rknpu_drv.h
@@ -10,6 +10,7 @@
 #include <linux/completion.h>
 #include <linux/device.h>
 #include <linux/kref.h>
+#include <linux/irq.h>
 #include <linux/platform_device.h>
 #include <linux/spinlock.h>
 #include <linux/regulator/consumer.h>
@@ -28,10 +29,10 @@
 
 #define DRIVER_NAME "rknpu"
 #define DRIVER_DESC "RKNPU driver"
-#define DRIVER_DATE "20231121"
+#define DRIVER_DATE "20240322"
 #define DRIVER_MAJOR 0
 #define DRIVER_MINOR 9
-#define DRIVER_PATCHLEVEL 3
+#define DRIVER_PATCHLEVEL 6
 
 #define LOG_TAG "RKNPU"
 
@@ -52,9 +53,18 @@
 #define LOG_DEV_DEBUG(dev, fmt, args...) dev_dbg(dev, LOG_TAG ": " fmt, ##args)
 #define LOG_DEV_ERROR(dev, fmt, args...) dev_err(dev, LOG_TAG ": " fmt, ##args)
 
-struct rknpu_reset_data {
-	const char *srst_a_name;
-	const char *srst_h_name;
+#define RKNPU_MAX_IOMMU_DOMAIN_NUM 16
+
+struct rknpu_irqs_data {
+	const char *name;
+	irqreturn_t (*irq_hdl)(int irq, void *ctx);
+};
+
+struct rknpu_amount_data {
+	uint16_t offset_clr_all;
+	uint16_t offset_dt_wr;
+	uint16_t offset_dt_rd;
+	uint16_t offset_wt_rd;
 };
 
 struct rknpu_config {
@@ -66,15 +76,14 @@ struct rknpu_config {
 	__u32 pc_task_number_mask;
 	__u32 pc_task_status_offset;
 	__u32 pc_dma_ctrl;
-	__u32 bw_enable;
 	const struct rknpu_irqs_data *irqs;
-	const struct rknpu_reset_data *resets;
 	int num_irqs;
-	int num_resets;
 	__u64 nbuf_phyaddr;
 	__u64 nbuf_size;
 	__u64 max_submit_number;
 	__u32 core_mask;
+	const struct rknpu_amount_data *amount_top;
+	const struct rknpu_amount_data *amount_core;
 };
 
 struct rknpu_timer {
@@ -113,13 +122,14 @@ struct rknpu_device {
 	spinlock_t irq_lock;
 	struct mutex power_lock;
 	struct mutex reset_lock;
+	struct mutex domain_lock;
 	struct rknpu_subcore_data subcore_datas[RKNPU_MAX_CORES];
 	const struct rknpu_config *config;
 	void __iomem *bw_priority_base;
 	struct rknpu_fence_context *fence_ctx;
 	bool iommu_en;
-	struct reset_control *srst_a[RKNPU_MAX_CORES];
-	struct reset_control *srst_h[RKNPU_MAX_CORES];
+	struct reset_control **srsts;
+	int num_srsts;
 	struct clk_bulk_data *clks;
 	int num_clks;
 	struct regulator *vdd;
@@ -156,6 +166,10 @@ struct rknpu_device {
 	void __iomem *nbuf_base_io;
 	struct rknpu_mm *sram_mm;
 	unsigned long power_put_delay;
+	struct iommu_group *iommu_group;
+	int iommu_domain_num;
+	int iommu_domain_id;
+	struct iommu_domain *iommu_domains[RKNPU_MAX_IOMMU_DOMAIN_NUM];
 };
 
 struct rknpu_session {
Index: kernel-rockchip/drivers/rknpu/include/rknpu_gem.h
===================================================================
--- kernel-rockchip.orig/drivers/rknpu/include/rknpu_gem.h
+++ kernel-rockchip/drivers/rknpu/include/rknpu_gem.h
@@ -60,6 +60,7 @@ struct rknpu_gem_object {
 	struct page **pages;
 	struct sg_table *sgt;
 	struct drm_mm_node mm_node;
+	int iommu_domain_id;
 };
 
 enum rknpu_cache_type {
@@ -71,7 +72,8 @@ enum rknpu_cache_type {
 struct rknpu_gem_object *rknpu_gem_object_create(struct drm_device *dev,
 						 unsigned int flags,
 						 unsigned long size,
-						 unsigned long sram_size);
+						 unsigned long sram_size,
+						 int iommu_domain_id);
 
 /* destroy a buffer with gem object */
 void rknpu_gem_object_destroy(struct rknpu_gem_object *rknpu_obj);
Index: kernel-rockchip/drivers/rknpu/include/rknpu_ioctl.h
===================================================================
--- kernel-rockchip.orig/drivers/rknpu/include/rknpu_ioctl.h
+++ kernel-rockchip/drivers/rknpu/include/rknpu_ioctl.h
@@ -31,11 +31,6 @@
 #define RKNPU_OFFSET_INT_STATUS 0x28
 #define RKNPU_OFFSET_INT_RAW_STATUS 0x2c
 
-#define RKNPU_OFFSET_CLR_ALL_RW_AMOUNT 0x8010
-#define RKNPU_OFFSET_DT_WR_AMOUNT 0x8034
-#define RKNPU_OFFSET_DT_RD_AMOUNT 0x8038
-#define RKNPU_OFFSET_WT_RD_AMOUNT 0x803c
-
 #define RKNPU_OFFSET_ENABLE_MASK 0xf008
 
 #define RKNPU_INT_CLEAR 0x1ffff
@@ -134,6 +129,8 @@ enum e_rknpu_action {
 	RKNPU_POWER_OFF = 21,
 	RKNPU_GET_TOTAL_SRAM_SIZE = 22,
 	RKNPU_GET_FREE_SRAM_SIZE = 23,
+	RKNPU_GET_IOMMU_DOMAIN_ID = 24,
+	RKNPU_SET_IOMMU_DOMAIN_ID = 25,
 };
 
 /**
@@ -147,6 +144,8 @@ enum e_rknpu_action {
  * @dma_addr: dma address that access by rknpu.
  * @sram_size: user-desired sram memory allocation size.
  *  - this size value would be page-aligned internally.
+ * @iommu_domain_id: iommu domain id
+ * @reserved: just padding to be 64-bit aligned.
  */
 struct rknpu_mem_create {
 	__u32 handle;
@@ -155,6 +154,8 @@ struct rknpu_mem_create {
 	__u64 obj_addr;
 	__u64 dma_addr;
 	__u64 sram_size;
+	__s32 iommu_domain_id;
+	__u32 reserved;
 };
 
 /**
@@ -249,7 +250,8 @@ struct rknpu_subcore_task {
  * @task_counter: task counter
  * @priority: submit priority
  * @task_obj_addr: address of task object
- * @regcfg_obj_addr: address of register config object
+ * @iommu_domain_id: iommu domain id
+ * @reserved: just padding to be 64-bit aligned.
  * @task_base_addr: task base address
  * @hw_elapse_time: hardware elapse time
  * @core_mask: core mask of rknpu
@@ -265,7 +267,8 @@ struct rknpu_submit {
 	__u32 task_counter;
 	__s32 priority;
 	__u64 task_obj_addr;
-	__u64 regcfg_obj_addr;
+	__u32 iommu_domain_id;
+	__u32 reserved;
 	__u64 task_base_addr;
 	__s64 hw_elapse_time;
 	__u32 core_mask;
Index: kernel-rockchip/drivers/rknpu/include/rknpu_iommu.h
===================================================================
--- kernel-rockchip.orig/drivers/rknpu/include/rknpu_iommu.h
+++ kernel-rockchip/drivers/rknpu/include/rknpu_iommu.h
@@ -37,4 +37,12 @@ dma_addr_t rknpu_iommu_dma_alloc_iova(st
 void rknpu_iommu_dma_free_iova(struct rknpu_iommu_dma_cookie *cookie,
 			       dma_addr_t iova, size_t size);
 
+int rknpu_iommu_init_domain(struct rknpu_device *rknpu_dev);
+int rknpu_iommu_switch_domain(struct rknpu_device *rknpu_dev, int domain_id);
+void rknpu_iommu_free_domains(struct rknpu_device *rknpu_dev);
+
+#if KERNEL_VERSION(5, 10, 0) < LINUX_VERSION_CODE
+int iommu_get_dma_cookie(struct iommu_domain *domain);
+#endif
+
 #endif
Index: kernel-rockchip/drivers/rknpu/include/rknpu_job.h
===================================================================
--- kernel-rockchip.orig/drivers/rknpu/include/rknpu_job.h
+++ kernel-rockchip/drivers/rknpu/include/rknpu_job.h
@@ -48,6 +48,7 @@ struct rknpu_job {
 	ktime_t hw_recoder_time;
 	ktime_t hw_elapse_time;
 	atomic_t submit_count[RKNPU_MAX_CORES];
+	int iommu_domain_id;
 };
 
 irqreturn_t rknpu_core0_irq_handler(int irq, void *data);
Index: kernel-rockchip/drivers/rknpu/include/rknpu_mem.h
===================================================================
--- kernel-rockchip.orig/drivers/rknpu/include/rknpu_mem.h
+++ kernel-rockchip/drivers/rknpu/include/rknpu_mem.h
@@ -37,10 +37,10 @@ struct rknpu_mem_object {
 	unsigned int owner;
 };
 
-int rknpu_mem_create_ioctl(struct rknpu_device *rknpu_dev, unsigned long data,
-			   struct file *file);
-int rknpu_mem_destroy_ioctl(struct rknpu_device *rknpu_dev, unsigned long data,
-			    struct file *file);
+int rknpu_mem_create_ioctl(struct rknpu_device *rknpu_dev, struct file *file,
+			   unsigned int cmd, unsigned long data);
+int rknpu_mem_destroy_ioctl(struct rknpu_device *rknpu_dev, struct file *file,
+			    unsigned long data);
 int rknpu_mem_sync_ioctl(struct rknpu_device *rknpu_dev, unsigned long data);
 
 #endif
Index: kernel-rockchip/drivers/rknpu/rknpu_devfreq.c
===================================================================
--- kernel-rockchip.orig/drivers/rknpu/rknpu_devfreq.c
+++ kernel-rockchip/drivers/rknpu/rknpu_devfreq.c
@@ -75,6 +75,25 @@ static struct devfreq_governor devfreq_r
 	.event_handler = devfreq_rknpu_ondemand_handler,
 };
 
+static int rk3576_npu_set_read_margin(struct device *dev,
+				      struct rockchip_opp_info *opp_info,
+				      u32 rm)
+{
+	if (!opp_info->grf || !opp_info->volt_rm_tbl)
+		return 0;
+
+	if (rm == opp_info->current_rm || rm == UINT_MAX)
+		return 0;
+
+	LOG_DEV_DEBUG(dev, "set rm to %d\n", rm);
+
+	regmap_write(opp_info->grf, 0x08, 0x001c0000 | (rm << 2));
+	regmap_write(opp_info->grf, 0x0c, 0x003c0000 | (rm << 2));
+	regmap_write(opp_info->grf, 0x10, 0x001c0000 | (rm << 2));
+
+	return 0;
+}
+
 static int rk3588_npu_get_soc_info(struct device *dev, struct device_node *np,
 				   int *bin, int *process)
 {
@@ -162,7 +181,6 @@ static int rk3588_npu_set_read_margin(st
 				      struct rockchip_opp_info *opp_info,
 				      u32 rm)
 {
-	struct rknpu_device *rknpu_dev = dev_get_drvdata(dev);
 	u32 offset = 0, val = 0;
 	int i, ret = 0;
 
@@ -174,7 +192,7 @@ static int rk3588_npu_set_read_margin(st
 
 	LOG_DEV_DEBUG(dev, "set rm to %d\n", rm);
 
-	for (i = 0; i < rknpu_dev->config->num_irqs; i++) {
+	for (i = 0; i < 3; i++) {
 		ret = regmap_read(opp_info->grf, offset, &val);
 		if (ret < 0) {
 			LOG_DEV_ERROR(dev, "failed to get rm from 0x%x\n",
@@ -214,6 +232,14 @@ static int npu_opp_config_clks(struct de
 }
 #endif
 
+static const struct rockchip_opp_data rk3576_npu_opp_data = {
+	.set_read_margin = rk3576_npu_set_read_margin,
+#if KERNEL_VERSION(6, 1, 0) <= LINUX_VERSION_CODE
+	.config_regulators = npu_opp_config_regulators,
+	.config_clks = npu_opp_config_clks,
+#endif
+};
+
 static const struct rockchip_opp_data rk3588_npu_opp_data = {
 	.get_soc_info = rk3588_npu_get_soc_info,
 	.set_soc_info = rk3588_npu_set_soc_info,
@@ -226,6 +252,10 @@ static const struct rockchip_opp_data rk
 
 static const struct of_device_id rockchip_npu_of_match[] = {
 	{
+		.compatible = "rockchip,rk3576",
+		.data = (void *)&rk3576_npu_opp_data,
+	},
+	{
 		.compatible = "rockchip,rk3588",
 		.data = (void *)&rk3588_npu_opp_data,
 	},
Index: kernel-rockchip/drivers/rknpu/rknpu_drv.c
===================================================================
--- kernel-rockchip.orig/drivers/rknpu/rknpu_drv.c
+++ kernel-rockchip/drivers/rknpu/rknpu_drv.c
@@ -8,7 +8,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/fs.h>
 #include <linux/interrupt.h>
-#include <linux/irq.h>
 #include <linux/irqdomain.h>
 #include <linux/iopoll.h>
 #include <linux/module.h>
@@ -44,6 +43,7 @@
 #include "rknpu_drv.h"
 #include "rknpu_gem.h"
 #include "rknpu_devfreq.h"
+#include "rknpu_iommu.h"
 
 #ifdef CONFIG_ROCKCHIP_RKNPU_DRM_GEM
 #include <drm/drm_device.h>
@@ -72,28 +72,40 @@ module_param(bypass_soft_reset, int, 064
 MODULE_PARM_DESC(bypass_soft_reset,
 		 "bypass RKNPU soft reset if set it to 1, disabled by default");
 
-struct rknpu_irqs_data {
-	const char *name;
-	irqreturn_t (*irq_hdl)(int irq, void *ctx);
-};
-
 static const struct rknpu_irqs_data rknpu_irqs[] = {
 	{ "npu_irq", rknpu_core0_irq_handler }
 };
 
+static const struct rknpu_irqs_data rk3576_npu_irqs[] = {
+	{ "npu0_irq", rknpu_core0_irq_handler },
+	{ "npu1_irq", rknpu_core1_irq_handler }
+};
+
 static const struct rknpu_irqs_data rk3588_npu_irqs[] = {
 	{ "npu0_irq", rknpu_core0_irq_handler },
 	{ "npu1_irq", rknpu_core1_irq_handler },
 	{ "npu2_irq", rknpu_core2_irq_handler }
 };
 
-static const struct rknpu_reset_data rknpu_resets[] = { { "srst_a",
-							  "srst_h" } };
+static const struct rknpu_amount_data rknpu_old_top_amount = {
+	.offset_clr_all = 0x8010,
+	.offset_dt_wr = 0x8034,
+	.offset_dt_rd = 0x8038,
+	.offset_wt_rd = 0x803c,
+};
+
+static const struct rknpu_amount_data rknpu_top_amount = {
+	.offset_clr_all = 0x2210,
+	.offset_dt_wr = 0x2234,
+	.offset_dt_rd = 0x2238,
+	.offset_wt_rd = 0x223c
+};
 
-static const struct rknpu_reset_data rk3588_npu_resets[] = {
-	{ "srst_a0", "srst_h0" },
-	{ "srst_a1", "srst_h1" },
-	{ "srst_a2", "srst_h2" }
+static const struct rknpu_amount_data rknpu_core_amount = {
+	.offset_clr_all = 0x2410,
+	.offset_dt_wr = 0x2434,
+	.offset_dt_rd = 0x2438,
+	.offset_wt_rd = 0x243c,
 };
 
 static const struct rknpu_config rk356x_rknpu_config = {
@@ -105,15 +117,14 @@ static const struct rknpu_config rk356x_
 	.pc_task_number_mask = 0xfff,
 	.pc_task_status_offset = 0x3c,
 	.pc_dma_ctrl = 0,
-	.bw_enable = 1,
 	.irqs = rknpu_irqs,
-	.resets = rknpu_resets,
 	.num_irqs = ARRAY_SIZE(rknpu_irqs),
-	.num_resets = ARRAY_SIZE(rknpu_resets),
 	.nbuf_phyaddr = 0,
 	.nbuf_size = 0,
 	.max_submit_number = (1 << 12) - 1,
 	.core_mask = 0x1,
+	.amount_top = &rknpu_old_top_amount,
+	.amount_core = NULL,
 };
 
 static const struct rknpu_config rk3588_rknpu_config = {
@@ -125,15 +136,14 @@ static const struct rknpu_config rk3588_
 	.pc_task_number_mask = 0xfff,
 	.pc_task_status_offset = 0x3c,
 	.pc_dma_ctrl = 0,
-	.bw_enable = 0,
 	.irqs = rk3588_npu_irqs,
-	.resets = rk3588_npu_resets,
 	.num_irqs = ARRAY_SIZE(rk3588_npu_irqs),
-	.num_resets = ARRAY_SIZE(rk3588_npu_resets),
 	.nbuf_phyaddr = 0,
 	.nbuf_size = 0,
 	.max_submit_number = (1 << 12) - 1,
 	.core_mask = 0x7,
+	.amount_top = NULL,
+	.amount_core = NULL,
 };
 
 static const struct rknpu_config rk3583_rknpu_config = {
@@ -145,15 +155,14 @@ static const struct rknpu_config rk3583_
 	.pc_task_number_mask = 0xfff,
 	.pc_task_status_offset = 0x3c,
 	.pc_dma_ctrl = 0,
-	.bw_enable = 0,
 	.irqs = rk3588_npu_irqs,
-	.resets = rk3588_npu_resets,
 	.num_irqs = 2,
-	.num_resets = 2,
 	.nbuf_phyaddr = 0,
 	.nbuf_size = 0,
 	.max_submit_number = (1 << 12) - 1,
 	.core_mask = 0x3,
+	.amount_top = NULL,
+	.amount_core = NULL,
 };
 
 static const struct rknpu_config rv1106_rknpu_config = {
@@ -165,15 +174,14 @@ static const struct rknpu_config rv1106_
 	.pc_task_number_mask = 0xffff,
 	.pc_task_status_offset = 0x3c,
 	.pc_dma_ctrl = 0,
-	.bw_enable = 1,
 	.irqs = rknpu_irqs,
-	.resets = rknpu_resets,
 	.num_irqs = ARRAY_SIZE(rknpu_irqs),
-	.num_resets = ARRAY_SIZE(rknpu_resets),
 	.nbuf_phyaddr = 0,
 	.nbuf_size = 0,
 	.max_submit_number = (1 << 16) - 1,
 	.core_mask = 0x1,
+	.amount_top = &rknpu_old_top_amount,
+	.amount_core = NULL,
 };
 
 static const struct rknpu_config rk3562_rknpu_config = {
@@ -185,15 +193,33 @@ static const struct rknpu_config rk3562_
 	.pc_task_number_mask = 0xffff,
 	.pc_task_status_offset = 0x48,
 	.pc_dma_ctrl = 1,
-	.bw_enable = 1,
 	.irqs = rknpu_irqs,
-	.resets = rknpu_resets,
 	.num_irqs = ARRAY_SIZE(rknpu_irqs),
-	.num_resets = ARRAY_SIZE(rknpu_resets),
 	.nbuf_phyaddr = 0xfe400000,
 	.nbuf_size = 256 * 1024,
 	.max_submit_number = (1 << 16) - 1,
 	.core_mask = 0x1,
+	.amount_top = &rknpu_old_top_amount,
+	.amount_core = NULL,
+};
+
+static const struct rknpu_config rk3576_rknpu_config = {
+	.bw_priority_addr = 0x0,
+	.bw_priority_length = 0x0,
+	.dma_mask = DMA_BIT_MASK(40),
+	.pc_data_amount_scale = 2,
+	.pc_task_number_bits = 16,
+	.pc_task_number_mask = 0xffff,
+	.pc_task_status_offset = 0x48,
+	.pc_dma_ctrl = 1,
+	.irqs = rk3576_npu_irqs,
+	.num_irqs = ARRAY_SIZE(rk3576_npu_irqs),
+	.nbuf_phyaddr = 0x3fe80000,
+	.nbuf_size = 1024 * 1024,
+	.max_submit_number = (1 << 16) - 1,
+	.core_mask = 0x3,
+	.amount_top = &rknpu_top_amount,
+	.amount_core = &rknpu_core_amount,
 };
 
 /* driver probe and init */
@@ -218,6 +244,10 @@ static const struct of_device_id rknpu_o
 		.compatible = "rockchip,rk3562-rknpu",
 		.data = &rk3562_rknpu_config,
 	},
+	{
+		.compatible = "rockchip,rk3576-rknpu",
+		.data = &rk3576_rknpu_config,
+	},
 	{},
 };
 
@@ -374,6 +404,15 @@ static int rknpu_action(struct rknpu_dev
 			args->value = 0;
 		ret = 0;
 		break;
+	case RKNPU_GET_IOMMU_DOMAIN_ID:
+		args->value = rknpu_dev->iommu_domain_id;
+		ret = 0;
+		break;
+	case RKNPU_SET_IOMMU_DOMAIN_ID: {
+		ret = rknpu_iommu_switch_domain(rknpu_dev,
+						*(int32_t *)&args->value);
+		break;
+	}
 	default:
 		ret = -EINVAL;
 		break;
@@ -463,7 +502,7 @@ static int rknpu_action_ioctl(struct rkn
 	return ret;
 }
 
-static long rknpu_ioctl(struct file *file, uint32_t cmd, unsigned long arg)
+static long rknpu_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	long ret = -EINVAL;
 	struct rknpu_device *rknpu_dev = NULL;
@@ -475,22 +514,22 @@ static long rknpu_ioctl(struct file *fil
 
 	rknpu_power_get(rknpu_dev);
 
-	switch (cmd) {
-	case IOCTL_RKNPU_ACTION:
+	switch (_IOC_NR(cmd)) {
+	case RKNPU_ACTION:
 		ret = rknpu_action_ioctl(rknpu_dev, arg);
 		break;
-	case IOCTL_RKNPU_SUBMIT:
+	case RKNPU_SUBMIT:
 		ret = rknpu_submit_ioctl(rknpu_dev, arg);
 		break;
-	case IOCTL_RKNPU_MEM_CREATE:
-		ret = rknpu_mem_create_ioctl(rknpu_dev, arg, file);
+	case RKNPU_MEM_CREATE:
+		ret = rknpu_mem_create_ioctl(rknpu_dev, file, cmd, arg);
 		break;
 	case RKNPU_MEM_MAP:
 		break;
-	case IOCTL_RKNPU_MEM_DESTROY:
-		ret = rknpu_mem_destroy_ioctl(rknpu_dev, arg, file);
+	case RKNPU_MEM_DESTROY:
+		ret = rknpu_mem_destroy_ioctl(rknpu_dev, file, arg);
 		break;
-	case IOCTL_RKNPU_MEM_SYNC:
+	case RKNPU_MEM_SYNC:
 		ret = rknpu_mem_sync_ioctl(rknpu_dev, arg);
 		break;
 	default:
@@ -952,9 +991,12 @@ static int rknpu_register_irq(struct pla
 {
 	const struct rknpu_config *config = rknpu_dev->config;
 	struct device *dev = &pdev->dev;
+#if KERNEL_VERSION(6, 1, 0) > LINUX_VERSION_CODE
 	struct resource *res;
+#endif
 	int i, ret, irq;
 
+#if KERNEL_VERSION(6, 1, 0) > LINUX_VERSION_CODE
 	res = platform_get_resource_byname(pdev, IORESOURCE_IRQ,
 					   config->irqs[0].name);
 	if (res) {
@@ -993,6 +1035,28 @@ static int rknpu_register_irq(struct pla
 			return ret;
 		}
 	}
+#else
+	/* there are irq names in dts */
+	for (i = 0; i < config->num_irqs; i++) {
+		irq = platform_get_irq_byname(pdev, config->irqs[i].name);
+		if (irq < 0) {
+			irq = platform_get_irq(pdev, i);
+			if (irq < 0) {
+				LOG_DEV_ERROR(dev, "no npu %s in dts\n",
+					      config->irqs[i].name);
+				return irq;
+			}
+		}
+
+		ret = devm_request_irq(dev, irq, config->irqs[i].irq_hdl,
+				       IRQF_SHARED, dev_name(dev), rknpu_dev);
+		if (ret < 0) {
+			LOG_DEV_ERROR(dev, "request %s failed: %d\n",
+				      config->irqs[i].name, ret);
+			return ret;
+		}
+	}
+#endif
 
 	return 0;
 }
@@ -1145,7 +1209,11 @@ static int rknpu_probe(struct platform_d
 	rknpu_dev->dev = dev;
 
 	rknpu_dev->iommu_en = rknpu_is_iommu_enable(dev);
-	if (!rknpu_dev->iommu_en) {
+	if (rknpu_dev->iommu_en) {
+		rknpu_dev->iommu_group = iommu_group_get(dev);
+		if (!rknpu_dev->iommu_group)
+			return -EINVAL;
+	} else {
 		/* Initialize reserved memory resources */
 		ret = of_reserved_mem_device_init(dev);
 		if (!ret) {
@@ -1200,6 +1268,7 @@ static int rknpu_probe(struct platform_d
 	spin_lock_init(&rknpu_dev->irq_lock);
 	mutex_init(&rknpu_dev->power_lock);
 	mutex_init(&rknpu_dev->reset_lock);
+	mutex_init(&rknpu_dev->domain_lock);
 	for (i = 0; i < config->num_irqs; i++) {
 		INIT_LIST_HEAD(&rknpu_dev->subcore_datas[i].todo_list);
 		init_waitqueue_head(&rknpu_dev->subcore_datas[i].job_done_wq);
@@ -1339,6 +1408,9 @@ static int rknpu_probe(struct platform_d
 	    rknpu_dev->config->nbuf_size > 0)
 		rknpu_find_nbuf_resource(rknpu_dev);
 
+	if (rknpu_dev->iommu_en)
+		rknpu_iommu_init_domain(rknpu_dev);
+
 	rknpu_power_off(rknpu_dev);
 	atomic_set(&rknpu_dev->power_refcount, 0);
 	atomic_set(&rknpu_dev->cmdline_power_refcount, 0);
@@ -1375,9 +1447,6 @@ static int rknpu_remove(struct platform_
 	cancel_delayed_work_sync(&rknpu_dev->power_off_work);
 	destroy_workqueue(rknpu_dev->power_off_wq);
 
-	if (IS_ENABLED(CONFIG_ROCKCHIP_RKNPU_SRAM) && rknpu_dev->sram_mm)
-		rknpu_mm_destroy(rknpu_dev->sram_mm);
-
 	rknpu_debugger_remove(rknpu_dev);
 	rknpu_cancel_timer(rknpu_dev);
 
@@ -1386,6 +1455,14 @@ static int rknpu_remove(struct platform_
 		WARN_ON(!list_empty(&rknpu_dev->subcore_datas[i].todo_list));
 	}
 
+	if (IS_ENABLED(CONFIG_ROCKCHIP_RKNPU_SRAM) && rknpu_dev->sram_mm)
+		rknpu_mm_destroy(rknpu_dev->sram_mm);
+
+	if (rknpu_dev->iommu_en) {
+		rknpu_iommu_free_domains(rknpu_dev);
+		iommu_group_put(rknpu_dev->iommu_group);
+	}
+
 #ifdef CONFIG_ROCKCHIP_RKNPU_DRM_GEM
 	rknpu_drm_remove(rknpu_dev);
 #endif
Index: kernel-rockchip/drivers/rknpu/rknpu_gem.c
===================================================================
--- kernel-rockchip.orig/drivers/rknpu/rknpu_gem.c
+++ kernel-rockchip/drivers/rknpu/rknpu_gem.c
@@ -15,6 +15,7 @@
 #include <linux/iommu.h>
 #include <linux/pfn_t.h>
 #include <linux/version.h>
+#include <linux/version_compat_defs.h>
 #include <asm/cacheflush.h>
 
 #if KERNEL_VERSION(5, 10, 0) <= LINUX_VERSION_CODE
@@ -615,7 +616,8 @@ static void rknpu_gem_free_buf_with_cach
 struct rknpu_gem_object *rknpu_gem_object_create(struct drm_device *drm,
 						 unsigned int flags,
 						 unsigned long size,
-						 unsigned long sram_size)
+						 unsigned long sram_size,
+						 int iommu_domain_id)
 {
 	struct rknpu_device *rknpu_dev = drm->dev_private;
 	struct rknpu_gem_object *rknpu_obj = NULL;
@@ -629,6 +631,13 @@ struct rknpu_gem_object *rknpu_gem_objec
 
 	remain_ddr_size = round_up(size, PAGE_SIZE);
 
+	rknpu_obj = rknpu_gem_init(drm, remain_ddr_size);
+	if (IS_ERR(rknpu_obj))
+		return rknpu_obj;
+
+	if (!rknpu_iommu_switch_domain(rknpu_dev, iommu_domain_id))
+		rknpu_obj->iommu_domain_id = iommu_domain_id;
+
 	if (!rknpu_dev->iommu_en && (flags & RKNPU_MEM_NON_CONTIGUOUS)) {
 		/*
 		 * when no IOMMU is available, all allocated buffers are
@@ -647,10 +656,6 @@ struct rknpu_gem_object *rknpu_gem_objec
 		if (sram_size != 0)
 			sram_size = round_up(sram_size, PAGE_SIZE);
 
-		rknpu_obj = rknpu_gem_init(drm, remain_ddr_size);
-		if (IS_ERR(rknpu_obj))
-			return rknpu_obj;
-
 		/* set memory type and cache attribute from user side. */
 		rknpu_obj->flags = flags;
 
@@ -687,15 +692,9 @@ struct rknpu_gem_object *rknpu_gem_objec
 	} else if (IS_ENABLED(CONFIG_NO_GKI) &&
 		   (flags & RKNPU_MEM_TRY_ALLOC_NBUF) &&
 		   rknpu_dev->nbuf_size > 0) {
-		size_t nbuf_size = 0;
-
-		rknpu_obj = rknpu_gem_init(drm, remain_ddr_size);
-		if (IS_ERR(rknpu_obj))
-			return rknpu_obj;
-
-		nbuf_size = remain_ddr_size <= rknpu_dev->nbuf_size ?
-				    remain_ddr_size :
-				    rknpu_dev->nbuf_size;
+		size_t nbuf_size = remain_ddr_size <= rknpu_dev->nbuf_size ?
+					   remain_ddr_size :
+					   rknpu_dev->nbuf_size;
 
 		/* set memory type and cache attribute from user side. */
 		rknpu_obj->flags = flags;
@@ -712,10 +711,6 @@ struct rknpu_gem_object *rknpu_gem_objec
 	}
 
 	if (remain_ddr_size > 0) {
-		rknpu_obj = rknpu_gem_init(drm, remain_ddr_size);
-		if (IS_ERR(rknpu_obj))
-			return rknpu_obj;
-
 		/* set memory type and cache attribute from user side. */
 		rknpu_obj->flags = flags;
 
@@ -724,13 +719,12 @@ struct rknpu_gem_object *rknpu_gem_objec
 			goto gem_release;
 	}
 
-	if (rknpu_obj)
-		LOG_DEBUG(
-			"created dma addr: %pad, cookie: %p, ddr size: %lu, sram size: %lu, nbuf size: %lu, attrs: %#lx, flags: %#x\n",
-			&rknpu_obj->dma_addr, rknpu_obj->cookie,
-			rknpu_obj->size, rknpu_obj->sram_size,
-			rknpu_obj->nbuf_size, rknpu_obj->dma_attrs,
-			rknpu_obj->flags);
+	LOG_DEBUG(
+		"created dma addr: %pad, cookie: %p, ddr size: %lu, sram size: %lu, nbuf size: %lu, attrs: %#lx, flags: %#x, iommu domain id: %d\n",
+		&rknpu_obj->dma_addr, rknpu_obj->cookie, rknpu_obj->size,
+		rknpu_obj->sram_size, rknpu_obj->nbuf_size,
+		rknpu_obj->dma_attrs, rknpu_obj->flags,
+		rknpu_obj->iommu_domain_id);
 
 	return rknpu_obj;
 
@@ -748,12 +742,15 @@ gem_release:
 void rknpu_gem_object_destroy(struct rknpu_gem_object *rknpu_obj)
 {
 	struct drm_gem_object *obj = &rknpu_obj->base;
+	struct rknpu_device *rknpu_dev = obj->dev->dev_private;
 
 	LOG_DEBUG(
 		"destroy dma addr: %pad, cookie: %p, size: %lu, attrs: %#lx, flags: %#x, handle count: %d\n",
 		&rknpu_obj->dma_addr, rknpu_obj->cookie, rknpu_obj->size,
 		rknpu_obj->dma_attrs, rknpu_obj->flags, obj->handle_count);
 
+	rknpu_iommu_switch_domain(rknpu_dev, rknpu_obj->iommu_domain_id);
+
 	/*
 	 * do not release memory region from exporter.
 	 *
@@ -766,8 +763,6 @@ void rknpu_gem_object_destroy(struct rkn
 	} else {
 		if (IS_ENABLED(CONFIG_ROCKCHIP_RKNPU_SRAM) &&
 		    rknpu_obj->sram_size > 0) {
-			struct rknpu_device *rknpu_dev = obj->dev->dev_private;
-
 			if (rknpu_obj->sram_obj != NULL)
 				rknpu_mm_free(rknpu_dev->sram_mm,
 					      rknpu_obj->sram_obj);
@@ -785,7 +780,7 @@ void rknpu_gem_object_destroy(struct rkn
 	rknpu_gem_release(rknpu_obj);
 }
 
-int rknpu_gem_create_ioctl(struct drm_device *dev, void *data,
+int rknpu_gem_create_ioctl(struct drm_device *drm, void *data,
 			   struct drm_file *file_priv)
 {
 	struct rknpu_mem_create *args = data;
@@ -794,8 +789,9 @@ int rknpu_gem_create_ioctl(struct drm_de
 
 	rknpu_obj = rknpu_gem_object_find(file_priv, args->handle);
 	if (!rknpu_obj) {
-		rknpu_obj = rknpu_gem_object_create(
-			dev, args->flags, args->size, args->sram_size);
+		rknpu_obj = rknpu_gem_object_create(drm, args->flags,
+						    args->size, args->sram_size,
+						    args->iommu_domain_id);
 		if (IS_ERR(rknpu_obj))
 			return PTR_ERR(rknpu_obj);
 
@@ -831,9 +827,10 @@ int rknpu_gem_map_ioctl(struct drm_devic
 #endif
 }
 
-int rknpu_gem_destroy_ioctl(struct drm_device *dev, void *data,
+int rknpu_gem_destroy_ioctl(struct drm_device *drm, void *data,
 			    struct drm_file *file_priv)
 {
+	struct rknpu_device *rknpu_dev = drm->dev_private;
 	struct rknpu_gem_object *rknpu_obj = NULL;
 	struct rknpu_mem_destroy *args = data;
 
@@ -841,6 +838,8 @@ int rknpu_gem_destroy_ioctl(struct drm_d
 	if (!rknpu_obj)
 		return -EINVAL;
 
+	rknpu_iommu_switch_domain(rknpu_dev, rknpu_obj->iommu_domain_id);
+
 	// rknpu_gem_object_put(&rknpu_obj->base);
 
 	return rknpu_gem_handle_destroy(file_priv, args->handle);
@@ -889,7 +888,7 @@ static int rknpu_gem_mmap_pages(struct r
 	struct drm_device *drm = rknpu_obj->base.dev;
 	int ret = -EINVAL;
 
-	vma->vm_flags |= VM_MIXEDMAP;
+	vm_flags_set(vma, VM_MIXEDMAP);
 
 	ret = __vm_map_pages(vma, rknpu_obj->pages, rknpu_obj->num_pages,
 			     vma->vm_pgoff);
@@ -935,7 +934,7 @@ static int rknpu_gem_mmap_cache(struct r
 		return -EINVAL;
 	}
 
-	vma->vm_flags |= VM_MIXEDMAP;
+	vm_flags_set(vma, VM_MIXEDMAP);
 
 	vm_size = vma->vm_end - vma->vm_start;
 
@@ -985,8 +984,8 @@ static int rknpu_gem_mmap_buffer(struct
 	 * vm_pgoff (used as a fake buffer offset by DRM) to 0 as we want to map
 	 * the whole buffer.
 	 */
-	vma->vm_flags |= VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP | VM_IO;
-	vma->vm_flags &= ~VM_PFNMAP;
+	vm_flags_set(vma, VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP | VM_IO);
+	vm_flags_clear(vma, VM_PFNMAP);
 	vma->vm_pgoff = 0;
 
 	vm_size = vma->vm_end - vma->vm_start;
@@ -1044,7 +1043,7 @@ int rknpu_gem_dumb_create(struct drm_fil
 	else
 		flags = RKNPU_MEM_CONTIGUOUS | RKNPU_MEM_WRITE_COMBINE;
 
-	rknpu_obj = rknpu_gem_object_create(drm, flags, args->size, 0);
+	rknpu_obj = rknpu_gem_object_create(drm, flags, args->size, 0, 0);
 	if (IS_ERR(rknpu_obj)) {
 		LOG_DEV_ERROR(drm->dev, "gem object allocate failed.\n");
 		return PTR_ERR(rknpu_obj);
@@ -1336,7 +1335,7 @@ int rknpu_gem_prime_vmap(struct drm_gem_
 		return -EINVAL;
 
 	vaddr = vmap(rknpu_obj->pages, rknpu_obj->num_pages, VM_MAP,
-			  PAGE_KERNEL);
+		     PAGE_KERNEL);
 	if (!vaddr)
 		return -ENOMEM;
 
Index: kernel-rockchip/drivers/rknpu/rknpu_iommu.c
===================================================================
--- kernel-rockchip.orig/drivers/rknpu/rknpu_iommu.c
+++ kernel-rockchip/drivers/rknpu/rknpu_iommu.c
@@ -59,3 +59,196 @@ void rknpu_iommu_dma_free_iova(struct rk
 
 	free_iova_fast(iovad, iova_pfn(iovad, iova), size >> iova_shift(iovad));
 }
+
+#if defined(CONFIG_IOMMU_API) && defined(CONFIG_NO_GKI)
+
+#if KERNEL_VERSION(6, 1, 0) <= LINUX_VERSION_CODE
+struct iommu_group {
+	struct kobject kobj;
+	struct kobject *devices_kobj;
+	struct list_head devices;
+#ifdef __ANDROID_COMMON_KERNEL__
+	struct xarray pasid_array;
+#endif
+	struct mutex mutex;
+	void *iommu_data;
+	void (*iommu_data_release)(void *iommu_data);
+	char *name;
+	int id;
+	struct iommu_domain *default_domain;
+	struct iommu_domain *blocking_domain;
+	struct iommu_domain *domain;
+	struct list_head entry;
+	unsigned int owner_cnt;
+	void *owner;
+};
+#else
+struct iommu_group {
+	struct kobject kobj;
+	struct kobject *devices_kobj;
+	struct list_head devices;
+	struct mutex mutex;
+	struct blocking_notifier_head notifier;
+	void *iommu_data;
+	void (*iommu_data_release)(void *iommu_data);
+	char *name;
+	int id;
+	struct iommu_domain *default_domain;
+	struct iommu_domain *domain;
+	struct list_head entry;
+};
+#endif
+
+int rknpu_iommu_init_domain(struct rknpu_device *rknpu_dev)
+{
+	// init domain 0
+	if (!rknpu_dev->iommu_domains[0]) {
+		rknpu_dev->iommu_domain_id = 0;
+		rknpu_dev->iommu_domains[rknpu_dev->iommu_domain_id] =
+			iommu_get_domain_for_dev(rknpu_dev->dev);
+		rknpu_dev->iommu_domain_num = 1;
+	}
+	return 0;
+}
+
+int rknpu_iommu_switch_domain(struct rknpu_device *rknpu_dev, int domain_id)
+{
+	struct iommu_domain *src_domain = NULL;
+	struct iommu_domain *dst_domain = NULL;
+	struct bus_type *bus = NULL;
+	int src_domain_id = 0;
+	int ret = -EINVAL;
+
+	if (!rknpu_dev->iommu_en)
+		return -EINVAL;
+
+	if (domain_id < 0 || domain_id > (RKNPU_MAX_IOMMU_DOMAIN_NUM - 1)) {
+		LOG_DEV_ERROR(
+			rknpu_dev->dev,
+			"invalid iommu domain id: %d, reuse domain id: %d\n",
+			domain_id, rknpu_dev->iommu_domain_id);
+		return -EINVAL;
+	}
+
+	bus = rknpu_dev->dev->bus;
+	if (!bus)
+		return -EFAULT;
+
+	mutex_lock(&rknpu_dev->domain_lock);
+
+	src_domain_id = rknpu_dev->iommu_domain_id;
+	if (domain_id == src_domain_id) {
+		mutex_unlock(&rknpu_dev->domain_lock);
+		return 0;
+	}
+
+	src_domain = iommu_get_domain_for_dev(rknpu_dev->dev);
+	if (src_domain != rknpu_dev->iommu_domains[src_domain_id]) {
+		LOG_DEV_ERROR(
+			rknpu_dev->dev,
+			"mismatch domain get from iommu_get_domain_for_dev\n");
+		mutex_unlock(&rknpu_dev->domain_lock);
+		return -EINVAL;
+	}
+
+	dst_domain = rknpu_dev->iommu_domains[domain_id];
+	if (dst_domain != NULL) {
+		iommu_detach_device(src_domain, rknpu_dev->dev);
+		ret = iommu_attach_device(dst_domain, rknpu_dev->dev);
+		if (ret) {
+			LOG_DEV_ERROR(
+				rknpu_dev->dev,
+				"failed to attach dst iommu domain, id: %d, ret: %d\n",
+				domain_id, ret);
+			if (iommu_attach_device(src_domain, rknpu_dev->dev)) {
+				LOG_DEV_ERROR(
+					rknpu_dev->dev,
+					"failed to reattach src iommu domain, id: %d\n",
+					src_domain_id);
+			}
+			mutex_unlock(&rknpu_dev->domain_lock);
+			return ret;
+		}
+		rknpu_dev->iommu_domain_id = domain_id;
+	} else {
+		uint64_t dma_limit = 1ULL << 32;
+
+		dst_domain = iommu_domain_alloc(bus);
+		if (!dst_domain) {
+			LOG_DEV_ERROR(rknpu_dev->dev,
+				      "failed to allocate iommu domain\n");
+			mutex_unlock(&rknpu_dev->domain_lock);
+			return -EIO;
+		}
+		// init domain iova_cookie
+		iommu_get_dma_cookie(dst_domain);
+
+		iommu_detach_device(src_domain, rknpu_dev->dev);
+		ret = iommu_attach_device(dst_domain, rknpu_dev->dev);
+		if (ret) {
+			LOG_DEV_ERROR(
+				rknpu_dev->dev,
+				"failed to attach iommu domain, id: %d, ret: %d\n",
+				domain_id, ret);
+			iommu_domain_free(dst_domain);
+			mutex_unlock(&rknpu_dev->domain_lock);
+			return ret;
+		}
+
+		// set domain type to dma domain
+		dst_domain->type |= __IOMMU_DOMAIN_DMA_API;
+		// iommu dma init domain
+		iommu_setup_dma_ops(rknpu_dev->dev, 0, dma_limit);
+
+		rknpu_dev->iommu_domain_id = domain_id;
+		rknpu_dev->iommu_domains[domain_id] = dst_domain;
+		rknpu_dev->iommu_domain_num++;
+	}
+
+	// reset default iommu domain
+	rknpu_dev->iommu_group->default_domain = dst_domain;
+
+	mutex_unlock(&rknpu_dev->domain_lock);
+
+	LOG_INFO("switch iommu domain from %d to %d\n", src_domain_id,
+		 domain_id);
+
+	return ret;
+}
+
+void rknpu_iommu_free_domains(struct rknpu_device *rknpu_dev)
+{
+	int i = 0;
+
+	rknpu_iommu_switch_domain(rknpu_dev, 0);
+
+	for (i = 1; i < RKNPU_MAX_IOMMU_DOMAIN_NUM; i++) {
+		struct iommu_domain *domain = rknpu_dev->iommu_domains[i];
+
+		if (domain == NULL)
+			continue;
+
+		iommu_detach_device(domain, rknpu_dev->dev);
+		iommu_domain_free(domain);
+
+		rknpu_dev->iommu_domains[i] = NULL;
+	}
+}
+
+#else
+
+int rknpu_iommu_init_domain(struct rknpu_device *rknpu_dev)
+{
+	return 0;
+}
+
+int rknpu_iommu_switch_domain(struct rknpu_device *rknpu_dev, int domain_id)
+{
+	return 0;
+}
+
+void rknpu_iommu_free_domains(struct rknpu_device *rknpu_dev)
+{
+}
+
+#endif
Index: kernel-rockchip/drivers/rknpu/rknpu_job.c
===================================================================
--- kernel-rockchip.orig/drivers/rknpu/rknpu_job.c
+++ kernel-rockchip/drivers/rknpu/rknpu_job.c
@@ -14,8 +14,9 @@
 #include "rknpu_reset.h"
 #include "rknpu_gem.h"
 #include "rknpu_fence.h"
-#include "rknpu_job.h"
 #include "rknpu_mem.h"
+#include "rknpu_iommu.h"
+#include "rknpu_job.h"
 
 #define _REG_READ(base, offset) readl(base + (offset))
 #define _REG_WRITE(base, value, offset) writel(value, base + (offset))
@@ -128,6 +129,7 @@ static inline struct rknpu_job *rknpu_jo
 						struct rknpu_submit *args)
 {
 	struct rknpu_job *job = NULL;
+	int i = 0;
 #ifdef CONFIG_ROCKCHIP_RKNPU_DRM_GEM
 	struct rknpu_gem_object *task_obj = NULL;
 #endif
@@ -143,6 +145,9 @@ static inline struct rknpu_job *rknpu_jo
 			    ((args->core_mask & RKNPU_CORE2_MASK) >> 2);
 	atomic_set(&job->run_count, job->use_core_num);
 	atomic_set(&job->interrupt_count, job->use_core_num);
+	job->iommu_domain_id = args->iommu_domain_id;
+	for (i = 0; i < rknpu_dev->config->num_irqs; i++)
+		atomic_set(&job->submit_count[i], 0);
 #ifdef CONFIG_ROCKCHIP_RKNPU_DRM_GEM
 	task_obj = (struct rknpu_gem_object *)(uintptr_t)args->task_obj_addr;
 	if (task_obj)
@@ -205,8 +210,9 @@ static inline int rknpu_job_wait(struct
 					(elapse_time_us < args->timeout * 1000);
 			spin_unlock_irqrestore(&rknpu_dev->irq_lock, flags);
 			LOG_ERROR(
-				"job: %p, wait_count: %d, continue wait: %d, commit elapse time: %lldus, wait time: %lldus, timeout: %uus\n",
-				job, wait_count, continue_wait,
+				"job: %p, iommu domain id: %d, wait_count: %d, continue wait: %d, commit elapse time: %lldus, wait time: %lldus, timeout: %uus\n",
+				job, job->iommu_domain_id, wait_count,
+				continue_wait,
 				(job->hw_commit_time == 0 ? 0 : elapse_time_us),
 				ktime_us_delta(ktime_get(), job->timestamp),
 				args->timeout * 1000);
@@ -837,6 +843,8 @@ int rknpu_submit_ioctl(struct drm_device
 	struct rknpu_device *rknpu_dev = dev_get_drvdata(dev->dev);
 	struct rknpu_submit *args = data;
 
+	rknpu_iommu_switch_domain(rknpu_dev, args->iommu_domain_id);
+
 	return rknpu_submit(rknpu_dev, args);
 }
 #endif
@@ -885,11 +893,6 @@ int rknpu_get_bw_priority(struct rknpu_d
 {
 	void __iomem *base = rknpu_dev->bw_priority_base;
 
-	if (!rknpu_dev->config->bw_enable) {
-		LOG_WARN("Get bw_priority is not supported on this device!\n");
-		return 0;
-	}
-
 	if (!base)
 		return -EINVAL;
 
@@ -914,11 +917,6 @@ int rknpu_set_bw_priority(struct rknpu_d
 {
 	void __iomem *base = rknpu_dev->bw_priority_base;
 
-	if (!rknpu_dev->config->bw_enable) {
-		LOG_WARN("Set bw_priority is not supported on this device!\n");
-		return 0;
-	}
-
 	if (!base)
 		return -EINVAL;
 
@@ -941,28 +939,41 @@ int rknpu_set_bw_priority(struct rknpu_d
 int rknpu_clear_rw_amount(struct rknpu_device *rknpu_dev)
 {
 	void __iomem *rknpu_core_base = rknpu_dev->base[0];
+	const struct rknpu_config *config = rknpu_dev->config;
 	unsigned long flags;
 
-	if (!rknpu_dev->config->bw_enable) {
+	if (config->amount_top == NULL) {
 		LOG_WARN("Clear rw_amount is not supported on this device!\n");
 		return 0;
 	}
 
-	if (rknpu_dev->config->pc_dma_ctrl) {
+	if (config->pc_dma_ctrl) {
 		uint32_t pc_data_addr = 0;
 
 		spin_lock_irqsave(&rknpu_dev->irq_lock, flags);
 		pc_data_addr = REG_READ(RKNPU_OFFSET_PC_DATA_ADDR);
 
 		REG_WRITE(0x1, RKNPU_OFFSET_PC_DATA_ADDR);
-		REG_WRITE(0x80000101, RKNPU_OFFSET_CLR_ALL_RW_AMOUNT);
-		REG_WRITE(0x00000101, RKNPU_OFFSET_CLR_ALL_RW_AMOUNT);
+		REG_WRITE(0x80000101, config->amount_top->offset_clr_all);
+		REG_WRITE(0x00000101, config->amount_top->offset_clr_all);
+		if (config->amount_core) {
+			REG_WRITE(0x80000101,
+				  config->amount_core->offset_clr_all);
+			REG_WRITE(0x00000101,
+				  config->amount_core->offset_clr_all);
+		}
 		REG_WRITE(pc_data_addr, RKNPU_OFFSET_PC_DATA_ADDR);
 		spin_unlock_irqrestore(&rknpu_dev->irq_lock, flags);
 	} else {
 		spin_lock(&rknpu_dev->lock);
-		REG_WRITE(0x80000101, RKNPU_OFFSET_CLR_ALL_RW_AMOUNT);
-		REG_WRITE(0x00000101, RKNPU_OFFSET_CLR_ALL_RW_AMOUNT);
+		REG_WRITE(0x80000101, config->amount_top->offset_clr_all);
+		REG_WRITE(0x00000101, config->amount_top->offset_clr_all);
+		if (config->amount_core) {
+			REG_WRITE(0x80000101,
+				  config->amount_core->offset_clr_all);
+			REG_WRITE(0x00000101,
+				  config->amount_core->offset_clr_all);
+		}
 		spin_unlock(&rknpu_dev->lock);
 	}
 
@@ -973,23 +984,42 @@ int rknpu_get_rw_amount(struct rknpu_dev
 			uint32_t *dt_rd, uint32_t *wd_rd)
 {
 	void __iomem *rknpu_core_base = rknpu_dev->base[0];
-	int amount_scale = rknpu_dev->config->pc_data_amount_scale;
+	const struct rknpu_config *config = rknpu_dev->config;
+	int amount_scale = config->pc_data_amount_scale;
 
-	if (!rknpu_dev->config->bw_enable) {
+	if (config->amount_top == NULL) {
 		LOG_WARN("Get rw_amount is not supported on this device!\n");
 		return 0;
 	}
 
 	spin_lock(&rknpu_dev->lock);
 
-	if (dt_wr != NULL)
-		*dt_wr = REG_READ(RKNPU_OFFSET_DT_WR_AMOUNT) * amount_scale;
+	if (dt_wr != NULL) {
+		*dt_wr = REG_READ(config->amount_top->offset_dt_wr) *
+			 amount_scale;
+		if (config->amount_core) {
+			*dt_wr += REG_READ(config->amount_core->offset_dt_wr) *
+				  amount_scale;
+		}
+	}
 
-	if (dt_rd != NULL)
-		*dt_rd = REG_READ(RKNPU_OFFSET_DT_RD_AMOUNT) * amount_scale;
+	if (dt_rd != NULL) {
+		*dt_rd = REG_READ(config->amount_top->offset_dt_rd) *
+			 amount_scale;
+		if (config->amount_core) {
+			*dt_rd += REG_READ(config->amount_core->offset_dt_rd) *
+				  amount_scale;
+		}
+	}
 
-	if (wd_rd != NULL)
-		*wd_rd = REG_READ(RKNPU_OFFSET_WT_RD_AMOUNT) * amount_scale;
+	if (wd_rd != NULL) {
+		*wd_rd = REG_READ(config->amount_top->offset_wt_rd) *
+			 amount_scale;
+		if (config->amount_core) {
+			*wd_rd += REG_READ(config->amount_core->offset_wt_rd) *
+				  amount_scale;
+		}
+	}
 
 	spin_unlock(&rknpu_dev->lock);
 
@@ -998,12 +1028,13 @@ int rknpu_get_rw_amount(struct rknpu_dev
 
 int rknpu_get_total_rw_amount(struct rknpu_device *rknpu_dev, uint32_t *amount)
 {
+	const struct rknpu_config *config = rknpu_dev->config;
 	uint32_t dt_wr = 0;
 	uint32_t dt_rd = 0;
 	uint32_t wd_rd = 0;
 	int ret = -EINVAL;
 
-	if (!rknpu_dev->config->bw_enable) {
+	if (config->amount_top == NULL) {
 		LOG_WARN(
 			"Get total_rw_amount is not supported on this device!\n");
 		return 0;
Index: kernel-rockchip/drivers/rknpu/rknpu_mem.c
===================================================================
--- kernel-rockchip.orig/drivers/rknpu/rknpu_mem.c
+++ kernel-rockchip/drivers/rknpu/rknpu_mem.c
@@ -17,8 +17,8 @@
 
 #ifdef CONFIG_ROCKCHIP_RKNPU_DMA_HEAP
 
-int rknpu_mem_create_ioctl(struct rknpu_device *rknpu_dev, unsigned long data,
-			   struct file *file)
+int rknpu_mem_create_ioctl(struct rknpu_device *rknpu_dev, struct file *file,
+			   unsigned int cmd, unsigned long data)
 {
 	struct rknpu_mem_create args;
 	int ret = -EINVAL;
@@ -33,14 +33,20 @@ int rknpu_mem_create_ioctl(struct rknpu_
 	struct rknpu_session *session = NULL;
 	int i, fd;
 	unsigned int length, page_count;
+	unsigned int in_size = _IOC_SIZE(cmd);
+	unsigned int k_size = sizeof(struct rknpu_mem_create);
+	char *k_data = (char *)&args;
 
 	if (unlikely(copy_from_user(&args, (struct rknpu_mem_create *)data,
-				    sizeof(struct rknpu_mem_create)))) {
+				    in_size))) {
 		LOG_ERROR("%s: copy_from_user failed\n", __func__);
 		ret = -EFAULT;
 		return ret;
 	}
 
+	if (k_size > in_size)
+		memset(k_data + in_size, 0, k_size - in_size);
+
 	if (args.flags & RKNPU_MEM_NON_CONTIGUOUS) {
 		LOG_ERROR("%s: malloc iommu memory unsupported in current!\n",
 			  __func__);
@@ -147,7 +153,7 @@ int rknpu_mem_create_ioctl(struct rknpu_
 		(__u64)rknpu_obj->dma_addr);
 
 	if (unlikely(copy_to_user((struct rknpu_mem_create *)data, &args,
-				  sizeof(struct rknpu_mem_create)))) {
+				  in_size))) {
 		LOG_ERROR("%s: copy_to_user failed\n", __func__);
 		ret = -EFAULT;
 		goto err_unmap_kv_addr;
@@ -194,8 +200,8 @@ err_free_obj:
 	return ret;
 }
 
-int rknpu_mem_destroy_ioctl(struct rknpu_device *rknpu_dev, unsigned long data,
-			    struct file *file)
+int rknpu_mem_destroy_ioctl(struct rknpu_device *rknpu_dev, struct file *file,
+			    unsigned long data)
 {
 	struct rknpu_mem_object *rknpu_obj, *entry, *q;
 	struct rknpu_session *session = NULL;
Index: kernel-rockchip/drivers/rknpu/rknpu_reset.c
===================================================================
--- kernel-rockchip.orig/drivers/rknpu/rknpu_reset.c
+++ kernel-rockchip/drivers/rknpu/rknpu_reset.c
@@ -28,27 +28,34 @@ static inline struct reset_control *rknp
 int rknpu_reset_get(struct rknpu_device *rknpu_dev)
 {
 #ifndef FPGA_PLATFORM
-	struct reset_control *srst_a = NULL;
-	struct reset_control *srst_h = NULL;
 	int i = 0;
+	int num_srsts = 0;
 
-	for (i = 0; i < rknpu_dev->config->num_resets; i++) {
-		srst_a = rknpu_reset_control_get(
-			rknpu_dev->dev,
-			rknpu_dev->config->resets[i].srst_a_name);
-		if (IS_ERR(srst_a))
-			return PTR_ERR(srst_a);
-
-		rknpu_dev->srst_a[i] = srst_a;
-
-		srst_h = rknpu_reset_control_get(
-			rknpu_dev->dev,
-			rknpu_dev->config->resets[i].srst_h_name);
-		if (IS_ERR(srst_h))
-			return PTR_ERR(srst_h);
+	num_srsts = of_count_phandle_with_args(rknpu_dev->dev->of_node,
+					       "resets", "#reset-cells");
+	if (num_srsts <= 0) {
+		LOG_DEV_ERROR(rknpu_dev->dev,
+			      "failed to get rknpu resets from dtb\n");
+		return num_srsts;
+	}
 
-		rknpu_dev->srst_h[i] = srst_h;
+	rknpu_dev->srsts = devm_kcalloc(rknpu_dev->dev, num_srsts,
+					sizeof(*rknpu_dev->srsts), GFP_KERNEL);
+	if (!rknpu_dev->srsts)
+		return -ENOMEM;
+
+	for (i = 0; i < num_srsts; ++i) {
+		rknpu_dev->srsts[i] = devm_reset_control_get_exclusive_by_index(
+			rknpu_dev->dev, i);
+		if (IS_ERR(rknpu_dev->srsts[i])) {
+			rknpu_dev->num_srsts = i;
+			return PTR_ERR(rknpu_dev->srsts[i]);
+		}
 	}
+
+	rknpu_dev->num_srsts = num_srsts;
+
+	return num_srsts;
 #endif
 
 	return 0;
@@ -93,7 +100,7 @@ int rknpu_soft_reset(struct rknpu_device
 #ifndef FPGA_PLATFORM
 	struct iommu_domain *domain = NULL;
 	struct rknpu_subcore_data *subcore_data = NULL;
-	int ret = -EINVAL, i = 0;
+	int ret = 0, i = 0;
 
 	if (rknpu_dev->bypass_soft_reset) {
 		LOG_WARN("bypass soft reset\n");
@@ -112,17 +119,17 @@ int rknpu_soft_reset(struct rknpu_device
 		wake_up(&subcore_data->job_done_wq);
 	}
 
-	LOG_INFO("soft reset\n");
+	LOG_INFO("soft reset, num: %d\n", rknpu_dev->num_srsts);
 
-	for (i = 0; i < rknpu_dev->config->num_resets; i++) {
-		ret = rknpu_reset_assert(rknpu_dev->srst_a[i]);
-		ret |= rknpu_reset_assert(rknpu_dev->srst_h[i]);
+	for (i = 0; i < rknpu_dev->num_srsts; ++i)
+		ret |= rknpu_reset_assert(rknpu_dev->srsts[i]);
 
-		udelay(10);
+	udelay(10);
 
-		ret |= rknpu_reset_deassert(rknpu_dev->srst_a[i]);
-		ret |= rknpu_reset_deassert(rknpu_dev->srst_h[i]);
-	}
+	for (i = 0; i < rknpu_dev->num_srsts; ++i)
+		ret |= rknpu_reset_deassert(rknpu_dev->srsts[i]);
+
+	udelay(10);
 
 	if (ret) {
 		LOG_DEV_ERROR(rknpu_dev->dev,
